---
title: "Project 1- Preprocessing"
authors: Eva Martín, Laura González
output:
  html_document:
    df_print: paged
---

#Libraries
```{r}
library(dplyr)
library(missMDA)
library(FactoMineR)
library(car)
library(mice)
library (chemometrics)
library(MASS)
library(AER)
library(effects)
library(lmtest)
library(DescTools)
library(ResourceSelection)
library(statmod)
library(cvAUC)
library(caret)
library(ModelMetrics)
library(pROC)

```
#Load dataset and create dataframe
```{r}
df <- read.csv("C:/Users/lglez/Documents/MDS/Q3/AML/AML-Project1/data/bank-full.csv",
               sep = ";")

summary(df)

df_no_dupl <- distinct(df) #there are no duplicates in our dataset 
rm(df_no_dupl)


```

#Exploratory analisis
Assign correct datatype to each variable
No missing values, so no imputation method is required
```{r}
sapply(df, class)

# Convert characaters to categorical variables 
df[sapply(df, is.character)] <- lapply(df[sapply(df, is.character)], as.factor)
summary (df)

```
#Variables. From the dataset source:
1 - age (numeric)
487 outliers, all on the upper side. 3 of them severe. Not normally distributed
```{r}
summary(df[,1])

hist(df$age, breaks = 40, freq = F);curve(dnorm(x, mean(df$age), sd(df$age)), add = T)

Boxplot(df$age)
length(Boxplot(df$age, id=list(n=Inf)))

varsumm1<-summary (df[,1])
iqr1 <- varsumm1[5]-varsumm1[2]

umout1 <- varsumm1[5]+1.5*iqr1; umout1
usout1 <- varsumm1[5]+3*iqr1; usout1

lmout1 <- varsumm1[2]-1.5*iqr1; lmout1
lsout1 <- varsumm1[2]-3*iqr1; lsout1

mout1<- which((df[,1]<lmout1)|(df[,1]>umout1));length(mout1) #487 mout
sout1 <-which((df[,1]<lsout1)|(df[,1]>usout1));length(sout1) #3 sout

```

2 - job : type of job (categorical:"admin.","unknown","unemployed","management","housemaid","entrepreneur","student","blue-collar","self-employed","retired","technician","services")
12 levels
```{r}
summary(df[,2])
str(df$job)
plot(df$job) 

```


3 - marital : marital status (categorical: "married","divorced","single"; note: "divorced" means divorced or widowed)
```{r}
summary(df[,3])
str(df$marital)
plot(df$marital) 
```

4 - education (categorical: "unknown","secondary","primary","tertiary")
```{r}
summary(df[,4])
str(df$education)
plot(df$education)
```

5 - default: has credit in default? (binary: "yes","no")
```{r}
summary(df[,5])
str(df$default)
plot(df$default)
```
6 - balance: average yearly balance, in euros (numeric)
about 15% of outliers. canidate for future categorical variable
```{r}
summary(df[,6])

hist(df$balance, breaks = 40, freq = F);curve(dnorm(x, mean(df$balance), sd(df$balance)), add = T)

Boxplot(df$balance)
length(Boxplot(df$balance, id=list(n=Inf)))

varsumm6<-summary (df[,6])
iqr6 <- varsumm6[5]-varsumm6[2]

umout6 <- varsumm6[5]+1.5*iqr6; umout6
usout6 <- varsumm6[5]+3*iqr6; usout6

lmout6 <- varsumm6[2]-1.5*iqr6; lmout6
lsout6 <- varsumm6[2]-3*iqr6; lsout6

mout6<- which((df[,6]<lmout6)|(df[,6]>umout6));length(mout6) #4729 mout
sout6 <-which((df[,6]<lsout6)|(df[,6]>usout6));length(sout6) #2443 sout
```

7 - housing: has housing loan? (binary: "yes","no")
```{r}
summary(df[,7])
str(df$housing)
plot(df$housing)
```


8 - loan: has personal loan? (binary: "yes","no")
```{r}
summary(df[,8])
str(df$loan)
plot(df$loan)
```

9 - contact: contact communication type (categorical: "unknown","telephone","cellular")
```{r}
summary(df[,9])
str(df$contact)
plot(df$contact)
```

10 - day: last contact day of the month (numeric)
doesn't make sense to treat it as a numeric value
```{r}
df$day <- as.factor(df$day)
summary(df[,10])
str(df$day)
plot(df$day)

```

11 - month: last contact month of year (categorical: "jan", "feb", "mar", …, "nov", "dec")
circular variable (after dec -> jan again)
```{r}
library(ggplot2)

# Order
df$month <- factor(df$month, 
                   levels = c("jan","feb","mar","apr","may","jun",
                              "jul","aug","sep","oct","nov","dec"),
                   ordered = TRUE)

# Codification
df$month_sin <- sin(2*pi*as.numeric(df$month)/12)
df$month_cos <- cos(2*pi*as.numeric(df$month)/12)

# Visualization
ggplot(df, aes(x = month_sin, y = month_cos, color = month)) +
  geom_point(size = 3, alpha = 0.9) +
  coord_equal() +
  theme_minimal() +
  scale_color_manual(values = c("jan"="#440154FF","feb"="#482878FF","mar"="#3E4989FF",
                                "apr"="#31688EFF","may"="#26828EFF","jun"="#1F9E89FF",
                                "jul"="#35B779FF","aug"="#6CCE59FF","sep"="#B4DE2CFF",
                                "oct"="#FDE725FF","nov"="#FDAE61FF","dec"="#D7191CFF")) +
  labs(
    title = "Cyclical encoding of the 'month' feature",
    x = "sin(month)", 
    y = "cos(month)", 
    color = "Month"
  )

months <- 1:12
plot(months, sin(2*pi*months/12), type="l", col="blue", ylim=c(-1,1)) 
lines(months, cos(2*pi*months/12), col="orange") 
legend("bottomleft", legend=c("sin","cos"), col=c("blue","orange"), lty=1) 
summary(df[,11]) 
str(df$month)
plot(df$month)

```

12 - duration: last contact duration, in seconds (numeric)
not normally dist
```{r}
summary(df[,12])

hist(df$duration, breaks = 40, freq = F);curve(dnorm(x, mean(df$duration), sd(df$duration)), add = T)

Boxplot(df$duration)
length(Boxplot(df$duration, id=list(n=Inf)))

varsumm12<-summary (df[,12])
iqr12 <- varsumm12[5]-varsumm12[2]

umout12 <- varsumm12[5]+1.5*iqr12; umout12
usout12<- varsumm12[5]+3*iqr12; usout12

lmout12<- varsumm12[2]-1.5*iqr12; lmout12
lsout12<- varsumm12[2]-3*iqr12; lsout12

mout12<- which((df[,12]<lmout12)|(df[,12]>umout12));length(mout12) #3235 mout
sout12<-which((df[,12]<lsout12)|(df[,12]>usout12));length(sout12) #1155 sout

```

13 - campaign: number of contacts performed during this campaign and for this client (numeric, includes last contact)
```{r}
summary(df[,13])

hist(df$campaign, breaks = 40, freq = F);curve(dnorm(x, mean(df$campaign), sd(df$campaign)), add = T)

Boxplot(df$campaign)
length(Boxplot(df$campaign, id=list(n=Inf)))

varsumm13<-summary (df[,13])
iqr13 <- varsumm13[5]-varsumm13[2]

umout13 <- varsumm13[5]+1.5*iqr13; umout13
usout13<- varsumm13[5]+3*iqr13; usout13

lmout13<- varsumm13[2]-1.5*iqr13; lmout13
lsout13<- varsumm13[2]-3*iqr13; lsout13

mout13<- which((df[,13]<lmout13)|(df[,13]>umout13));length(mout13) #3064 mout
sout13<-which((df[,13]<lsout13)|(df[,13]>usout13));length(sout13) #1462 sout

```

14 - pdays: number of days that passed by after the client was last contacted from a previous campaign (numeric, -1 means client was not previously contacted)
problematic variable. addressed in 2 different variables:
- binary value if was contacted or not 
- replace -1 with nas: 82 % of NAs -> remove feature
```{r}
df$was_contacted <- ifelse(df$pdays == -1, 0, 1)
df$was_contacted <- as.factor(df$was_contacted)
summary(df$was_contacted)
str(df$was_contacted)
plot(df$was_contacted)

df$pdays <- ifelse(df$pdays == -1, NA, df$pdays)
summary (df$pdays)
df <- subset(df, select = -pdays)
summary(df)

```


15 - previous: number of contacts performed before this campaign and for this client (numeric)
```{r}
summary(df[,14])

hist(df$previous, breaks = 40, freq = F);curve(dnorm(x, mean(df$previous), sd(df$previous)), add = T)

Boxplot(df$previous)
length(Boxplot(df$previous, id=list(n=Inf)))

varsumm14<-summary (df[,14])
iqr14 <- varsumm14[5]-varsumm14[2]

umout14 <- varsumm14[5]+1.5*iqr14; umout14
usout14<- varsumm14[5]+3*iqr14; usout14

lmout14<- varsumm14[2]-1.5*iqr14; lmout14
lsout14<- varsumm14[2]-3*iqr14; lsout14

mout14<- which((df[,14]<lmout14)|(df[,14]>umout14));length(mout14) #8257 mout
sout14<-which((df[,14]<lsout14)|(df[,14]>usout14));length(sout14) #8257 sout
```


16 - poutcome: outcome of the previous marketing campaign (categorical: "unknown","other","failure","success")
```{r}
summary(df[,15])
str(df$poutcome)
plot(df$poutcome)
```


Output variable (desired target):
17 - y - has the client subscribed a term deposit? (binary: "yes","no")

```{r}
summary(df[,16])
str(df$y)
plot(df$y)
prop.table(table(df$y)) * 100
```

Check if the remaining numerical features are correlated somehow
```{r}
library(corrplot)


num_vars <- c("age", "balance", "duration", "campaign", "previous")

cor_matrix <- cor(df[, num_vars], use = "complete.obs")

par(mar = c(1, 1, 3, 2)) 

corrplot(
  cor_matrix, 
  method = "color",
  tl.cex = 0.9,             
  tl.col = "black",         
  title = "Correlation matrix of numerical variables",
  mar = c(0, 0, 2, 0),      
  addgrid.col = "grey90",   
  cl.pos = "r"             
)


```

# Data preparation

```{r}
# ============================================================
# DATA PREPROCESSING PIPELINE 
# ============================================================

# ---  Start from EDA dataframe ---
df_clean <- df

# Remove original 'month' variable (cyclical encoding already present)
if ("month" %in% names(df_clean)) {
  df_clean <- subset(df_clean, select = -month)
  cat("Removed original 'month' variable (cyclical encoding already present).\n")
}

# ============================================================
# ---  Split dataset into training and testing subsets ---
# ============================================================

set.seed(123)
N <- nrow(df_clean)
learn <- sample(1:N, round(2 * N / 3))
nlearn <- length(learn)
ntest  <- N - nlearn

train <- df_clean[learn, ]
test  <- df_clean[-learn, ]

cat("Training set size:", nlearn, "\n")
cat("Testing set size:", ntest, "\n")

# ============================================================
# ---  Outlier treatment via Winsorization ---
# ============================================================

num_outliers <- c("balance", "duration", "previous", "campaign")

winsorize <- function(x, p = 0.99) {
  upper <- quantile(x, p, na.rm = TRUE)
  x[x > upper] <- upper
  return(x)
}

train$balance  <- winsorize(train$balance,  p = 0.99)
train$duration <- winsorize(train$duration, p = 0.99)
train$previous <- winsorize(train$previous, p = 0.99)
train$campaign <- winsorize(train$campaign, p = 0.995)

test$balance  <- winsorize(test$balance,  p = 0.99)
test$duration <- winsorize(test$duration, p = 0.99)
test$previous <- winsorize(test$previous, p = 0.99)
test$campaign <- winsorize(test$campaign, p = 0.995)

cat("Winsorization thresholds:\n")
cat(" - balance  capped at:", quantile(train$balance, 0.99,  na.rm = TRUE), "\n")
cat(" - duration capped at:", quantile(train$duration, 0.99, na.rm = TRUE), "\n")
cat(" - previous capped at:", quantile(train$previous, 0.99, na.rm = TRUE), "\n")
cat(" - campaign capped at:", quantile(train$campaign, 0.995, na.rm = TRUE), "\n")

# ============================================================
# ---  Log-transform highly skewed continuous variables ---
# ============================================================

# Following Kashyap (2023): log(1 + x) reduces skewness while preserving interpretability
min_balance <- min(train$balance, na.rm = TRUE)
if (min_balance <= 0) {
  train$balance <- train$balance - min_balance + 1
  test$balance  <- test$balance  - min_balance + 1
}

train$balance  <- log1p(train$balance)
test$balance   <- log1p(test$balance)
train$duration <- log1p(train$duration)
test$duration  <- log1p(test$duration)

# ============================================================
# ---  Standardization (Z-score scaling) ---
# ============================================================

num_vars <- sapply(train, is.numeric)

train_means <- sapply(train[, num_vars], mean, na.rm = TRUE)
train_sds   <- sapply(train[, num_vars], sd,   na.rm = TRUE)

train[, num_vars] <- scale(train[, num_vars],
                           center = train_means,
                           scale  = train_sds)

test[,  num_vars] <- scale(test[,  num_vars],
                           center = train_means,
                           scale  = train_sds)

# ============================================================
# ---  Encoding categorical variables ---
# ============================================================

if (!"y" %in% names(train)) stop("Column 'y' not found in training data.")
train$y <- factor(train$y, levels = c("no", "yes"))
test$y  <- factor(test$y,  levels = c("no", "yes"))

# Remove columns that are all-NA or constant
train <- train[, colSums(is.na(train)) < nrow(train)]
test  <- test[,  colSums(is.na(test))  < nrow(test)]

# Convert character columns to factors (unordered)
train[sapply(train, is.character)] <- lapply(train[sapply(train, is.character)], as.factor)
test[sapply(test,  is.character)]  <- lapply(test[sapply(test,  is.character)],  as.factor)

# Create a contrast list only for factor variables
contr_list_train <- lapply(train[, sapply(train, is.factor), drop = FALSE],
                           function(x) contrasts(x, contrasts = FALSE))
contr_list_test  <- lapply(test[, sapply(test, is.factor), drop = FALSE],
                           function(x) contrasts(x, contrasts = FALSE))

# One-hot encoding (remove intercept)
X_train <- model.matrix(y ~ ., data = train, contrasts.arg = contr_list_train)[, -1, drop = FALSE]
y_train <- train$y
X_test  <- model.matrix(y ~ ., data = test,  contrasts.arg = contr_list_test)[, -1, drop = FALSE]
y_test  <- test$y

cat("Dimensions of X_train:", dim(X_train), "\n")
cat("Dimensions of X_test :", dim(X_test), "\n")
table(y_train)


# ============================================================
# ---  Balance target variable (SMOTE) ---
# ============================================================

library(smotefamily)

X_train_df  <- as.data.frame(X_train)
y_train_vec <- as.factor(y_train)

set.seed(123)
smote_res <- SMOTE(X_train_df, y_train_vec, K = 5, dup_size = 5)
train_bal <- smote_res$data
train_bal$class <- factor(train_bal$class, levels = c("no", "yes"))

cat("Balanced class proportions:\n")
print(prop.table(table(train_bal$class)))

# ============================================================
# ---  Multicollinearity and redundancy diagnostics ---
# ============================================================

library(caret)
X <- model.matrix(class ~ ., data = train_bal)[, -1]

kappa_val <- base::kappa(X)
cat("\nInitial condition number (kappa):", kappa_val, "\n")

if (kappa_val < 30) {
  cat("No significant multicollinearity detected.\n")
} else if (kappa_val < 100) {
  cat("Moderate multicollinearity.\n")
} else {
  cat("Strong multicollinearity detected — cleaning required.\n")
}

nzv <- nearZeroVar(X, saveMetrics = TRUE)
if (any(nzv$nzv)) {
  cat("\nRemoving near-zero variance variables:\n")
  print(rownames(nzv[nzv$nzv == TRUE, ]))
  X <- X[, !nzv$nzv]
}

combos <- findLinearCombos(X)
if (!is.null(combos$remove)) {
  cat("\nRemoving linear combinations:\n")
  print(colnames(X)[combos$remove])
  X <- X[, -combos$remove]
}

# Correlation check
cor_mat <- cor(X, use = "pairwise.complete.obs")
high_cor <- findCorrelation(cor_mat, cutoff = 0.95, names = TRUE)
cat("\nHighly correlated variables (|r| > 0.95):\n")
print(high_cor)

# Remove redundant dummy if necessary
X <- X[, setdiff(colnames(X), "poutcomeunknown")]

# Final condition number
kappa_val <- base::kappa(X)
cat("\nFinal condition number (kappa):", kappa_val, "\n")

# ============================================================
# ---  Exploratory PCA  ---
# ============================================================

library(FactoMineR)
library(factoextra)

X_pca <- as.data.frame(X)
pca <- prcomp(X_pca, center = TRUE, scale. = TRUE)

# Explained variance
summary(pca)

# Scree plot
fviz_eig(pca, addlabels = TRUE, barfill = "steelblue", barcolor = "steelblue") +
  theme_minimal() +
  labs(title = "Explained variance by principal components")

# Variable contributions
fviz_pca_var(pca,
             col.var = "contrib",
             gradient.cols = c("lightblue", "steelblue", "darkblue"),
             repel = TRUE) +
  theme_minimal() +
  labs(title = "PCA - Variable contributions")


```



